%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);
%}
%term END=';' ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' LT='<' GT='>' EQ='=' OR='|' AND='&' INDEX='[' PARAMS=','
%term FINIT='(' BLOCO='{'
%include "y.tab.h"
%%


finit: FINIT(blocop, params)
finit: FINIT(blocop, NIL)

blocop: NIL
blocop: bloco

%! VERIFY (provavelmente separar o END eventualmente)
bloco: BLOCO(END(list,brk),decls)
bloco: BLOCO(list,decls)


list: base
list: END(list,base)




%! FIXME fazer o codigo
brk: BREAK(INT)         1   {}
brk: CONTINUE(INT)      1   {}

%!stmt:	VOID 1	{	}




%! fix this
tipo: INTEGER 1 {}
tipo: STRING 1 {}
tipo: NUMBER 1 {}

init: ID 1 {}

params: PARAMS(params,param)  1 {}

decls: END(decls,param)

param: PARAM(tipo,ID)


base: VOID
base: bloco
base: expr

%! while alterado para o nosso codigo Verificar postfix VERIFY
base:   WHILE(do,expr)   1 { brkcnt--; fprintf(outfp, pfJMP pfLABEL, mklbl(LEFT_CHILD(LEFT_CHILD(p))-    >place), mklbl(LEFT_CHILD(p)->place)); }
do: DO(begin,stmt) 1 { p->place = (brklbl[++brkcnt] = ++lbl); fprintf(outfp, pfJZ, mklbl(lbl)); }
begin:  START        1 { p->place = ++lbl; fprintf(outfp, pfLABEL, mklbl(lbl)); }

%! pre/post in/de-crement Completamente diferente(no code tem apenas 1 arg) FIXME
%!expr:   INC(CTE, lval)  1 { fprintf(outfp, pfDUP pfINCR pfLOAD, LEFT_CHILD(p)->value.i); }
%!expr:   DEC(CTE, lval)  1 { fprintf(outfp, pfDUP pfDECR pfLOAD, LEFT_CHILD(p)->value.i); }
%!expr:   INC(lval, CTE)  1 { fprintf(outfp, pfDUP pfLOAD pfSWAP pfINCR, RIGHT_CHILD(p)->value.i); }
%!expr:   DEC(lval, CTE)  1 { fprintf(outfp, pfDUP pfLOAD pfSWAP pfDECR, RIGHT_CHILD(p)->value.i); }


expr:   ADD(expr,expr)  1 { fprintf(outfp, pfADD); }
expr:   SUB(expr,expr)  1 { fprintf(outfp, pfSUB); }
expr:   MUL(expr,expr)  1 { fprintf(outfp, pfMUL); }
expr:   DIV(expr,expr)  1 { fprintf(outfp, pfDIV); }
expr:   MOD(expr,expr)  1 { fprintf(outfp, pfMOD); }
expr:   EQ(expr,expr)   1 { fprintf(outfp, pfEQ); }
expr:   NE(expr,expr)   1 { fprintf(outfp, pfNE); }
expr:   LT(expr,expr)   1 { fprintf(outfp, pfLT); }
expr:   LE(expr,expr)   1 { fprintf(outfp, pfLE); }
expr:   GT(expr,expr)   1 { fprintf(outfp, pfGT); }
expr:   GE(expr,expr)   1 { fprintf(outfp, pfGE); }
expr:   UMINUS(expr)    1 { fprintf(outfp, pfNEG); }

expr:   NOT(expr)   1 { fprintf(outfp, pfIMM pfEQ, 0); }

expr:   AND(and,expr)   1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
and:    expr        1 { p->place = ++lbl; fprintf(outfp, pfDUP pfJZ pfTRASH, mklbl(p->place), pfWORD); }
expr:   OR(or,expr) 1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
or: expr        1 { p->place = ++lbl; fprintf(outfp, pfDUP pfJNZ pfTRASH, mklbl(p->place), pfWORD); }


%! if-else
stmt:   ELSE(if,stmt)   1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
if: IF(cond,stmt)   1 { p->place = ++lbl; fprintf(outfp, pfJMP pfLABEL,mklbl(p->place), mklbl(LEFT_CHILD(p)->place)); }

%! simple if (no else): uses only one label
stmt:   IF(cond,stmt)   1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
cond:   expr        1 { p->place = ++lbl; fprintf(outfp, pfJZ, mklbl(p->place)); }

%! left values
lv: INDEX(lv,expr) 1 { fprintf(outfp, pfIMM pfMUL pfADD, pfWORD); }
%! falta os diversis type
lv: LOCAL  1 { fprintf(outfp, pfLOCAL, p->value.i * (pfWORD/4)); }


%! Sera q nos usamos load? * lv

%! isto faz em comment(tb comment in B)
%!stmt: CALL(LOAD(ADDR),ARG(STRING,END))    doasm { fprintf(outfp, "%s\n", LEFT_CHILD(RIGHT_CHILD(p))- >value.s); }
expr:   CALL(ID,args)   1 { fprintf(outfp, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)(pfWORD*(RIGHT_CHILD(p)->place))); }


args:   PARAMS(arg,args)     { p->place =  ((LEFT_CHILD(p)->place) + (RIGHT_CHILD(p)->place)); }
args:   END       { p->place = 0; }
%! VERIFICAR ARGUMENTO PK DOS TIPOS PARA O ENTER acima no mkfunc
arg:    expr        1 { p->place = 1; }




%%
#include "y.tab.h"
extern void yyerror(const char*);
extern char **yynames;
extern int trace;

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
    int op = OP_LABEL(p);
    YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
    /* fprintf(stderr, "0x%lx:%s matched %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno],   cost, bestcost); */
    if (cost >= MAX_COST && bestcost >= MAX_COST) {
      extern char **yynames;
      fprintf(stderr, "0x%lx:%s NO MATCH %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno],   cost, bestcost);
      printNode(p, 0, yynames);
    }
}
#endif

